#!/usr/bin/env python3
import sys
import numpy as np
from enum import Enum

class I(Enum):
    SINGLE = 0xf
    LD   = 0x0
    ST   = 0x1
    ADD  = 0x2
    ADDI = 0x3
    ADDIC= 0x4
    SUB  = 0x5
    JMP  = 0x6
    JC   = 0x7
    CMP  = 0x8
    CMPI = 0x9
    NOR  = 0xa
    NORI = 0xb
    AND  = 0xc
    XOR  = 0xd
    LH   = 0xe
    GT   = 0xf0
    LT   = 0xf2
    EQ   = 0xf3
    NE   = 0xf4
    NC   = 0xf5
    SIGN = 0xf6
    NEG  = 0xf7
    SHL  = 0xf8
    SHR  = 0xf9
    SHL4 = 0xfa
    ROL  = 0xfc
    ROR  = 0xfd
    SWAP = 0xfe
    ASR  = 0xff

twobyte_inst = [
    I.LD,
    I.ST,
    I.ADD,
    I.SUB,
    I.JMP,
    I.JC,
    I.CMP,
    I.NOR,
    I.AND,
    I.XOR
]

mem_indirect = [
    I.ADD,
    I.SUB,
    I.CMP,
    I.NOR,
    I.AND,
    I.XOR
]

table = []
with open("74181_table.csv", "r") as f:
    for line in f:
        line = line.rstrip().split()
        table.append([int(x) for x in line])

table = np.array(table)

def alu_74181(a, b, s, m, cin):
    index = cin | (m << 1) | (s << 2) | ((b & 0xf) << 6) | ((a & 0xf) << 10)
    flo, c, _ = table[index]
    index = c | (m << 1) | (s << 2) | ((b >> 4) << 6) | ((a >> 4) << 10)
    fhi, c, _ = table[index]
    r = flo | (fhi << 4)
    return r, c, r == 0

def main(argv):
    mem_size = 4096
    program_counter = 0
    a_register = 0
    program = []
    assert len(argv) >= 2, "sim <program>"

    in_stream = [[]] * 16
    if len(argv) == 3:
        inp = []
        with open(sys.argv[2], "r") as f:
            for line in sys.stdin:
                line = line.rstrip().split()
                inp += line
        inp = [int(i, 16) for i in inp]
        index = 0
        for i, x in enumerate(inp):
            if i % 2 == 0:
                index = x & 0x0f
            else:
                in_stream[index] = x & 0xff

    with open(argv[1], "r") as f:
        for line in f:
            if line[:5] == "const":
                continue
            if line[:2] == "};":
                continue
            line = line.rstrip().split()
            line = [w[:-1] if w[-1] == ',' else w for w in line]
            line = [int(w, 16) for w in line]
            program += line
    cflag, zflag = 0, 0

    mem = [0] * mem_size
    assert len(program) < mem_size
    for i, x in enumerate(program):
        mem[i] = x

    cycle = 0
    terminate = False
    # 2 discard output, 1 set Cin to 1, 0 set Cin to carry input 
    rotate_inst = {
                                            # C 01234567
        I.SIGN: [2],                        # 0 01234567
        I.SHL:  [1],                        # 7 6543210Z
        I.SHR:  [1, 0, 0, 0, 0, 0, 0, 0],   # 7 z0123456
        I.SHL4: [1, 1, 1, 1],               # 3 4567zzzz
        I.ROL:  [2, 0],                     # 0 12345670
        I.ROR:  [2, 0] * 7,                 # 6 70123456
        I.SWAP: [2, 0] * 4,                 # 3 45670123
        I.ASR:  [2, 0, 0, 0, 0, 0, 0, 0, 0] # 7 00123456
    }

    while not terminate:
        assert program_counter < mem_size, "out of range"
        inst = mem[program_counter]
        # decode
        opc = I(inst >> 4)
        operand = inst & 0xf
        if opc in twobyte_inst:
            # 12 bit address (unsigned)
            program_counter += 1
            assert program_counter < mem_size, "out of range"
            operand = (operand << 8) | mem[program_counter]
            if opc in mem_indirect:
                operand = mem[operand]
        elif opc == I.SINGLE:
            pass
        elif I(opc) == I.LH:
            operand = operand << 4
        else:
            # immediate operand
            operand |= 0 if (operand & 8) == 0 else 0xf0

        # Deocder
        opc = I(opc)
        if opc == I.LH:
            a_register = operand
            cycle += 2
        elif opc == I.LD:
            if (operand >> 4) == 0xff:
                a_register = in_stream[operand & 0x0f][0]
                in_stream[operand & 0x0f] = in_stream[operand & 0x0f][1:]
                print("i {} {}".format((operand & 0x0f), a_register))
            else:
                a_register = mem[operand]
            cycle += 3
        elif opc == I.ST:
            if (operand >> 4) == 0xff:
                print("o {} {}".format((operand & 0x0f), a_register))
            else:
                mem[operand] = a_register
            cycle += 3
        elif opc == I.ADD or opc == I.ADDI or opc == I.ADDIC:
            # addi 0 prints status()
            if opc == I.ADDI and operand == 0:
                print("CYCLE {:4d} PC {:4d} A {:4d} {:2x} C {} Z {}".format(
                    cycle,
                    program_counter,
                    a_register, a_register,
                    cflag,
                    int(zflag),
                ))
            a_register, cflag, zflag = alu_74181(
                a_register,
                operand,
                9,
                0,
                cflag if opc == I.ADDIC else 1,
            )
            cycle += 3 if opc == I.ADD else 2
        elif opc == I.SUB:
            a_register, cflag, zflag = alu_74181(
                a_register,
                operand,
                6,
                0,
                0
            )
            cycle += 3
        elif opc == I.JMP:
            if program_counter == operand + 1:
                terminate = True
            program_counter = operand - 1
            cycle += 2
        elif opc == I.JC:
            if not cflag:
                program_counter = operand - 1
            cycle += 2
        elif opc == I.CMP or opc == I.CMPI:
            _, cflag, zflag = alu_74181(
                a_register,
                operand,
                6,
                0,
                0
            )
            cycle += 3 if opc == I.CMP else 2
        elif opc == I.AND or opc == I.XOR or opc == I.NOR or opc == I.NORI:
            a_register, cflag, zflag = alu_74181(
                a_register,
                operand,
                4 if opc == I.AND else (9 if opc == I.XOR else 1),
                1,
                0
            )
            cycle += 3 if opc != I.NORI else 2
        elif opc == I.SINGLE:
            flags = {
                I.GT: cflag or zflag,
                I.LT: not cflag or zflag, 
                I.EQ: not zflag,
                I.NE: zflag,
                I.NC: not cflag
            }
            opc = I(inst)
            if opc in flags:
                _, cflag, zflag = alu_74181(
                    a_register,
                    operand,
                    3,
                    0,
                    flags[opc]
                )
                cycle += 2
            elif opc == I.NEG:
                # not
                a_register, _, _ = alu_74181(
                    a_register,
                    operand,
                    0,
                    1,
                    1
                )
                # + 1
                a_register, cflag, zflag = alu_74181(
                    a_register,
                    operand,
                    0,
                    0,
                    0
                )
                cycle += 3
            elif opc in rotate_inst:
                for i in rotate_inst[opc]:
                    x, cflag, zflag = alu_74181(
                        a_register,
                        operand,
                        12,
                        0,
                        cflag if i == 0 else 1
                    )
                    if i != 2:
                        a_register = x
                cycle += 1 + len(rotate_inst[opc])

        program_counter += 1
    print("CYCLE {:4d} PC {:4d} A {:4d} {:2x} C {} Z {}".format(
        cycle,
        program_counter,
        a_register, a_register,
        cflag,
        int(zflag),
    ))

if __name__ == "__main__":
    main(sys.argv)
